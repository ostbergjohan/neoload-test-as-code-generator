"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkyaml_generator"] = self["webpackChunkyaml_generator"] || []).push([["vendors-node_modules_digi_arbetsformedlingen_dist_esm_digi-chart-line_entry_js"],{

/***/ "./node_modules/@digi/arbetsformedlingen/dist/esm/digi-chart-line.entry.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@digi/arbetsformedlingen/dist/esm/digi-chart-line.entry.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   digi_chart_line: () => (/* binding */ ChartLine)\n/* harmony export */ });\n/* harmony import */ var _index_de760108_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-de760108.js */ \"./node_modules/@digi/arbetsformedlingen/dist/esm/index-de760108.js\");\n/* harmony import */ var _text_f08f550e_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./text-f08f550e.js */ \"./node_modules/@digi/arbetsformedlingen/dist/esm/text-f08f550e.js\");\n/* harmony import */ var _linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear-ef018ffb.js */ \"./node_modules/@digi/arbetsformedlingen/dist/esm/linear-ef018ffb.js\");\n/* harmony import */ var _randomIdGenerator_util_9cf19c59_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./randomIdGenerator.util-9cf19c59.js */ \"./node_modules/@digi/arbetsformedlingen/dist/esm/randomIdGenerator.util-9cf19c59.js\");\n\n\n\n\n\nfunction sourceEvent(event) {\n  let sourceEvent;\n  while (sourceEvent = event.sourceEvent) event = sourceEvent;\n  return event;\n}\n\nfunction pointer(event, node) {\n  event = sourceEvent(event);\n  if (node === undefined) node = event.currentTarget;\n  if (node) {\n    var svg = node.ownerSVGElement || node;\n    if (svg.createSVGPoint) {\n      var point = svg.createSVGPoint();\n      point.x = event.clientX, point.y = event.clientY;\n      point = point.matrixTransform(node.getScreenCTM().inverse());\n      return [point.x, point.y];\n    }\n    if (node.getBoundingClientRect) {\n      var rect = node.getBoundingClientRect();\n      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];\n    }\n  }\n  return [event.pageX, event.pageY];\n}\n\n// These are typically used in conjunction with noevent to ensure that we can\n// preventDefault on the event.\nconst nonpassive = {passive: false};\nconst nonpassivecapture = {capture: true, passive: false};\n\nfunction nopropagation(event) {\n  event.stopImmediatePropagation();\n}\n\nfunction noevent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n}\n\nfunction dragDisable(view) {\n  var root = view.document.documentElement,\n      selection = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(view).on(\"dragstart.drag\", noevent, nonpassivecapture);\n  if (\"onselectstart\" in root) {\n    selection.on(\"selectstart.drag\", noevent, nonpassivecapture);\n  } else {\n    root.__noselect = root.style.MozUserSelect;\n    root.style.MozUserSelect = \"none\";\n  }\n}\n\nfunction yesdrag(view, noclick) {\n  var root = view.document.documentElement,\n      selection = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(view).on(\"dragstart.drag\", null);\n  if (noclick) {\n    selection.on(\"click.drag\", noevent, nonpassivecapture);\n    setTimeout(function() { selection.on(\"click.drag\", null); }, 0);\n  }\n  if (\"onselectstart\" in root) {\n    selection.on(\"selectstart.drag\", null);\n  } else {\n    root.style.MozUserSelect = root.__noselect;\n    delete root.__noselect;\n  }\n}\n\nconst constant$1 = x => () => x;\n\nfunction DragEvent(type, {\n  sourceEvent,\n  subject,\n  target,\n  identifier,\n  active,\n  x, y, dx, dy,\n  dispatch\n}) {\n  Object.defineProperties(this, {\n    type: {value: type, enumerable: true, configurable: true},\n    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},\n    subject: {value: subject, enumerable: true, configurable: true},\n    target: {value: target, enumerable: true, configurable: true},\n    identifier: {value: identifier, enumerable: true, configurable: true},\n    active: {value: active, enumerable: true, configurable: true},\n    x: {value: x, enumerable: true, configurable: true},\n    y: {value: y, enumerable: true, configurable: true},\n    dx: {value: dx, enumerable: true, configurable: true},\n    dy: {value: dy, enumerable: true, configurable: true},\n    _: {value: dispatch}\n  });\n}\n\nDragEvent.prototype.on = function() {\n  var value = this._.on.apply(this._, arguments);\n  return value === this._ ? this : value;\n};\n\n// Ignore right-click, since that should open the context menu.\nfunction defaultFilter(event) {\n  return !event.ctrlKey && !event.button;\n}\n\nfunction defaultContainer() {\n  return this.parentNode;\n}\n\nfunction defaultSubject(event, d) {\n  return d == null ? {x: event.x, y: event.y} : d;\n}\n\nfunction defaultTouchable() {\n  return navigator.maxTouchPoints || (\"ontouchstart\" in this);\n}\n\nfunction drag() {\n  var filter = defaultFilter,\n      container = defaultContainer,\n      subject = defaultSubject,\n      touchable = defaultTouchable,\n      gestures = {},\n      listeners = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.f)(\"start\", \"drag\", \"end\"),\n      active = 0,\n      mousedownx,\n      mousedowny,\n      mousemoving,\n      touchending,\n      clickDistance2 = 0;\n\n  function drag(selection) {\n    selection\n        .on(\"mousedown.drag\", mousedowned)\n      .filter(touchable)\n        .on(\"touchstart.drag\", touchstarted)\n        .on(\"touchmove.drag\", touchmoved, nonpassive)\n        .on(\"touchend.drag touchcancel.drag\", touchended)\n        .style(\"touch-action\", \"none\")\n        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\n  }\n\n  function mousedowned(event, d) {\n    if (touchending || !filter.call(this, event, d)) return;\n    var gesture = beforestart(this, container.call(this, event, d), event, d, \"mouse\");\n    if (!gesture) return;\n    (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(event.view)\n      .on(\"mousemove.drag\", mousemoved, nonpassivecapture)\n      .on(\"mouseup.drag\", mouseupped, nonpassivecapture);\n    dragDisable(event.view);\n    nopropagation(event);\n    mousemoving = false;\n    mousedownx = event.clientX;\n    mousedowny = event.clientY;\n    gesture(\"start\", event);\n  }\n\n  function mousemoved(event) {\n    noevent(event);\n    if (!mousemoving) {\n      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;\n      mousemoving = dx * dx + dy * dy > clickDistance2;\n    }\n    gestures.mouse(\"drag\", event);\n  }\n\n  function mouseupped(event) {\n    (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(event.view).on(\"mousemove.drag mouseup.drag\", null);\n    yesdrag(event.view, mousemoving);\n    noevent(event);\n    gestures.mouse(\"end\", event);\n  }\n\n  function touchstarted(event, d) {\n    if (!filter.call(this, event, d)) return;\n    var touches = event.changedTouches,\n        c = container.call(this, event, d),\n        n = touches.length, i, gesture;\n\n    for (i = 0; i < n; ++i) {\n      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {\n        nopropagation(event);\n        gesture(\"start\", event, touches[i]);\n      }\n    }\n  }\n\n  function touchmoved(event) {\n    var touches = event.changedTouches,\n        n = touches.length, i, gesture;\n\n    for (i = 0; i < n; ++i) {\n      if (gesture = gestures[touches[i].identifier]) {\n        noevent(event);\n        gesture(\"drag\", event, touches[i]);\n      }\n    }\n  }\n\n  function touchended(event) {\n    var touches = event.changedTouches,\n        n = touches.length, i, gesture;\n\n    if (touchending) clearTimeout(touchending);\n    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!\n    for (i = 0; i < n; ++i) {\n      if (gesture = gestures[touches[i].identifier]) {\n        nopropagation(event);\n        gesture(\"end\", event, touches[i]);\n      }\n    }\n  }\n\n  function beforestart(that, container, event, d, identifier, touch) {\n    var dispatch = listeners.copy(),\n        p = pointer(touch || event, container), dx, dy,\n        s;\n\n    if ((s = subject.call(that, new DragEvent(\"beforestart\", {\n        sourceEvent: event,\n        target: drag,\n        identifier,\n        active,\n        x: p[0],\n        y: p[1],\n        dx: 0,\n        dy: 0,\n        dispatch\n      }), d)) == null) return;\n\n    dx = s.x - p[0] || 0;\n    dy = s.y - p[1] || 0;\n\n    return function gesture(type, event, touch) {\n      var p0 = p, n;\n      switch (type) {\n        case \"start\": gestures[identifier] = gesture, n = active++; break;\n        case \"end\": delete gestures[identifier], --active; // falls through\n        case \"drag\": p = pointer(touch || event, container), n = active; break;\n      }\n      dispatch.call(\n        type,\n        that,\n        new DragEvent(type, {\n          sourceEvent: event,\n          subject: s,\n          target: drag,\n          identifier,\n          active: n,\n          x: p[0] + dx,\n          y: p[1] + dy,\n          dx: p[0] - p0[0],\n          dy: p[1] - p0[1],\n          dispatch\n        }),\n        d\n      );\n    };\n  }\n\n  drag.filter = function(_) {\n    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant$1(!!_), drag) : filter;\n  };\n\n  drag.container = function(_) {\n    return arguments.length ? (container = typeof _ === \"function\" ? _ : constant$1(_), drag) : container;\n  };\n\n  drag.subject = function(_) {\n    return arguments.length ? (subject = typeof _ === \"function\" ? _ : constant$1(_), drag) : subject;\n  };\n\n  drag.touchable = function(_) {\n    return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant$1(!!_), drag) : touchable;\n  };\n\n  drag.on = function() {\n    var value = listeners.on.apply(listeners, arguments);\n    return value === listeners ? drag : value;\n  };\n\n  drag.clickDistance = function(_) {\n    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);\n  };\n\n  return drag;\n}\n\nfunction quadInOut(t) {\n  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;\n}\n\nconst pi$1 = Math.PI,\n    tau$1 = 2 * pi$1,\n    epsilon = 1e-6,\n    tauEpsilon = tau$1 - epsilon;\n\nfunction append(strings) {\n  this._ += strings[0];\n  for (let i = 1, n = strings.length; i < n; ++i) {\n    this._ += arguments[i] + strings[i];\n  }\n}\n\nfunction appendRound(digits) {\n  let d = Math.floor(digits);\n  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);\n  if (d > 15) return append;\n  const k = 10 ** d;\n  return function(strings) {\n    this._ += strings[0];\n    for (let i = 1, n = strings.length; i < n; ++i) {\n      this._ += Math.round(arguments[i] * k) / k + strings[i];\n    }\n  };\n}\n\nclass Path {\n  constructor(digits) {\n    this._x0 = this._y0 = // start of current subpath\n    this._x1 = this._y1 = null; // end of current subpath\n    this._ = \"\";\n    this._append = digits == null ? append : appendRound(digits);\n  }\n  moveTo(x, y) {\n    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;\n  }\n  closePath() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._append`Z`;\n    }\n  }\n  lineTo(x, y) {\n    this._append`L${this._x1 = +x},${this._y1 = +y}`;\n  }\n  quadraticCurveTo(x1, y1, x, y) {\n    this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y}`;\n  }\n  bezierCurveTo(x1, y1, x2, y2, x, y) {\n    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;\n  }\n  arcTo(x1, y1, x2, y2, r) {\n    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(`negative radius: ${r}`);\n\n    let x0 = this._x1,\n        y0 = this._y1,\n        x21 = x2 - x1,\n        y21 = y2 - y1,\n        x01 = x0 - x1,\n        y01 = y0 - y1,\n        l01_2 = x01 * x01 + y01 * y01;\n\n    // Is this path empty? Move to (x1,y1).\n    if (this._x1 === null) {\n      this._append`M${this._x1 = x1},${this._y1 = y1}`;\n    }\n\n    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n    else if (!(l01_2 > epsilon));\n\n    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n    // Equivalently, is (x1,y1) coincident with (x2,y2)?\n    // Or, is the radius zero? Line to (x1,y1).\n    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n      this._append`L${this._x1 = x1},${this._y1 = y1}`;\n    }\n\n    // Otherwise, draw an arc!\n    else {\n      let x20 = x2 - x0,\n          y20 = y2 - y0,\n          l21_2 = x21 * x21 + y21 * y21,\n          l20_2 = x20 * x20 + y20 * y20,\n          l21 = Math.sqrt(l21_2),\n          l01 = Math.sqrt(l01_2),\n          l = r * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n          t01 = l / l01,\n          t21 = l / l21;\n\n      // If the start tangent is not coincident with (x0,y0), line to.\n      if (Math.abs(t01 - 1) > epsilon) {\n        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;\n      }\n\n      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;\n    }\n  }\n  arc(x, y, r, a0, a1, ccw) {\n    x = +x, y = +y, r = +r, ccw = !!ccw;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(`negative radius: ${r}`);\n\n    let dx = r * Math.cos(a0),\n        dy = r * Math.sin(a0),\n        x0 = x + dx,\n        y0 = y + dy,\n        cw = 1 ^ ccw,\n        da = ccw ? a0 - a1 : a1 - a0;\n\n    // Is this path empty? Move to (x0,y0).\n    if (this._x1 === null) {\n      this._append`M${x0},${y0}`;\n    }\n\n    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n      this._append`L${x0},${y0}`;\n    }\n\n    // Is this arc empty? We’re done.\n    if (!r) return;\n\n    // Does the angle go the wrong way? Flip the direction.\n    if (da < 0) da = da % tau$1 + tau$1;\n\n    // Is this a complete circle? Draw two arcs to complete the circle.\n    if (da > tauEpsilon) {\n      this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;\n    }\n\n    // Is this arc non-empty? Draw an arc!\n    else if (da > epsilon) {\n      this._append`A${r},${r},0,${+(da >= pi$1)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;\n    }\n  }\n  rect(x, y, w, h) {\n    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;\n  }\n  toString() {\n    return this._;\n  }\n}\n\nfunction constant(x) {\n  return function constant() {\n    return x;\n  };\n}\n\nconst cos = Math.cos;\nconst sin = Math.sin;\nconst sqrt = Math.sqrt;\nconst pi = Math.PI;\nconst tau = 2 * pi;\n\nfunction withPath(shape) {\n  let digits = 3;\n\n  shape.digits = function(_) {\n    if (!arguments.length) return digits;\n    if (_ == null) {\n      digits = null;\n    } else {\n      const d = Math.floor(_);\n      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);\n      digits = d;\n    }\n    return shape;\n  };\n\n  return () => new Path(digits);\n}\n\nfunction array(x) {\n  return typeof x === \"object\" && \"length\" in x\n    ? x // Array, TypedArray, NodeList, array-like\n    : Array.from(x); // Map, Set, iterable, string, or anything else\n}\n\nfunction Linear(context) {\n  this._context = context;\n}\n\nLinear.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // falls through\n      default: this._context.lineTo(x, y); break;\n    }\n  }\n};\n\nfunction curveLinear(context) {\n  return new Linear(context);\n}\n\nfunction x(p) {\n  return p[0];\n}\n\nfunction y(p) {\n  return p[1];\n}\n\nfunction line(x$1, y$1) {\n  var defined = constant(true),\n      context = null,\n      curve = curveLinear,\n      output = null,\n      path = withPath(line);\n\n  x$1 = typeof x$1 === \"function\" ? x$1 : (x$1 === undefined) ? x : constant(x$1);\n  y$1 = typeof y$1 === \"function\" ? y$1 : (y$1 === undefined) ? y : constant(y$1);\n\n  function line(data) {\n    var i,\n        n = (data = array(data)).length,\n        d,\n        defined0 = false,\n        buffer;\n\n    if (context == null) output = curve(buffer = path());\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) output.lineStart();\n        else output.lineEnd();\n      }\n      if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));\n    }\n\n    if (buffer) return output = null, buffer + \"\" || null;\n  }\n\n  line.x = function(_) {\n    return arguments.length ? (x$1 = typeof _ === \"function\" ? _ : constant(+_), line) : x$1;\n  };\n\n  line.y = function(_) {\n    return arguments.length ? (y$1 = typeof _ === \"function\" ? _ : constant(+_), line) : y$1;\n  };\n\n  line.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant(!!_), line) : defined;\n  };\n\n  line.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;\n  };\n\n  line.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;\n  };\n\n  return line;\n}\n\nconst circle = {\n  draw(context, size) {\n    const r = sqrt(size / pi);\n    context.moveTo(r, 0);\n    context.arc(0, 0, r, 0, tau);\n  }\n};\n\nconst tan30 = sqrt(1 / 3);\nconst tan30_2 = tan30 * 2;\n\nconst diamond = {\n  draw(context, size) {\n    const y = sqrt(size / tan30_2);\n    const x = y * tan30;\n    context.moveTo(0, -y);\n    context.lineTo(x, 0);\n    context.lineTo(0, y);\n    context.lineTo(-x, 0);\n    context.closePath();\n  }\n};\n\nconst ka = 0.89081309152928522810;\nconst kr = sin(pi / 10) / sin(7 * pi / 10);\nconst kx = sin(tau / 10) * kr;\nconst ky = -cos(tau / 10) * kr;\n\nconst star = {\n  draw(context, size) {\n    const r = sqrt(size * ka);\n    const x = kx * r;\n    const y = ky * r;\n    context.moveTo(0, -r);\n    context.lineTo(x, y);\n    for (let i = 1; i < 5; ++i) {\n      const a = tau * i / 5;\n      const c = cos(a);\n      const s = sin(a);\n      context.lineTo(s * r, -c * r);\n      context.lineTo(c * x - s * y, s * x + c * y);\n    }\n    context.closePath();\n  }\n};\n\nconst sqrt3 = sqrt(3);\n\nconst triangle = {\n  draw(context, size) {\n    const y = -sqrt(size / (sqrt3 * 3));\n    context.moveTo(0, y * 2);\n    context.lineTo(-sqrt3 * y, -y);\n    context.lineTo(sqrt3 * y, -y);\n    context.closePath();\n  }\n};\n\nfunction Symbol(type, size) {\n  let context = null,\n      path = withPath(symbol);\n\n  type = typeof type === \"function\" ? type : constant(type || circle);\n  size = typeof size === \"function\" ? size : constant(size === undefined ? 64 : +size);\n\n  function symbol() {\n    let buffer;\n    if (!context) context = buffer = path();\n    type.apply(this, arguments).draw(context, +size.apply(this, arguments));\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  symbol.type = function(_) {\n    return arguments.length ? (type = typeof _ === \"function\" ? _ : constant(_), symbol) : type;\n  };\n\n  symbol.size = function(_) {\n    return arguments.length ? (size = typeof _ === \"function\" ? _ : constant(+_), symbol) : size;\n  };\n\n  symbol.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, symbol) : context;\n  };\n\n  return symbol;\n}\n\nfunction point(that, x, y) {\n  that._context.bezierCurveTo(\n    (2 * that._x0 + that._x1) / 3,\n    (2 * that._y0 + that._y1) / 3,\n    (that._x0 + 2 * that._x1) / 3,\n    (that._y0 + 2 * that._y1) / 3,\n    (that._x0 + 4 * that._x1 + x) / 6,\n    (that._y0 + 4 * that._y1 + y) / 6\n  );\n}\n\nfunction Basis(context) {\n  this._context = context;\n}\n\nBasis.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 3: point(this, this._x1, this._y1); // falls through\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // falls through\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nfunction basis(context) {\n  return new Basis(context);\n}\n\nconst chartLineCss = \".sc-digi-chart-line-h{display:block;height:100%;width:100%;position:relative}.sc-digi-chart-line-h .digi-chart-line.sc-digi-chart-line{color:var(--MY-PROP);height:100%;width:100%;min-height:fit-content}.buttonWrapper.sc-digi-chart-line{--digi--button--padding--medium:0 0 0.75rem 0}.chart.sc-digi-chart-line{box-sizing:content-box;width:auto}.chartTitle.sc-digi-chart-line{--digi--typography--h2--margin:0.5rem;--digi--typography--h3--margin:0.5rem;--digi--typography--h4--margin:0.5rem;--digi--typography--h5--margin:0.5rem;--digi--typography--h6--margin:0.5rem;display:flex;justify-content:flex-start;flex-direction:column;align-items:left;text-align:left;padding-bottom:1rem;flex-grow:2}.close.sc-digi-chart-line{--digi--icon--color:rgb(245, 245, 245);cursor:pointer;margin-top:-5px}.legend.sc-digi-chart-line{display:flex;flex-direction:row;flex-wrap:no-wrap;gap:0.5rem;margin:0.5rem 0;margin-top:1.25rem;height:2.675rem;overflow-x:auto;overflow-y:hidden;cursor:default;max-width:100%}.chip.sc-digi-chart-line{box-sizing:border-box}.legend.sc-digi-chart-line::-webkit-scrollbar,.table.sc-digi-chart-line::-webkit-scrollbar{height:10px;width:10px}.legend.sc-digi-chart-line::-webkit-scrollbar-track,.table.sc-digi-chart-line::-webkit-scrollbar-track{background:whitesmoke;border-radius:4px}.legend.sc-digi-chart-line::-webkit-scrollbar-thumb,.table.sc-digi-chart-line::-webkit-scrollbar-thumb{background-color:lightgray;border-radius:4px;border:0}.chartTooltip.sc-digi-chart-line{box-sizing:border-box;position:absolute;background-color:rgba(10, 10, 10, 0.9);color:white;padding:5px 10px;padding-right:5px;border-radius:4px;display:flex;flex-direction:row;align-items:flex-start;box-shadow:rgba(60, 64, 67, 0.3) 0px 1px 2px 0px, rgba(60, 64, 67, 0.15) 0px 2px 6px 2px;font-size:14px;display:none}.scChartStatus.sc-digi-chart-line{border:0;clip:rect(1px, 1px, 1px, 1px);clip-path:inset(50%);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap}.table.sc-digi-chart-line{display:none;overflow-y:scroll;height:fit-content;border-radius:4px;padding:0.25rem;background:linear-gradient(white 30%, rgba(255, 255, 255, 0)) center top, linear-gradient(rgba(255, 255, 255, 0), white 70%) center bottom, radial-gradient(farthest-side at 50% 0, rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0)) center top, radial-gradient(farthest-side at 50% 100%, rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0)) center bottom;background-repeat:no-repeat;background-size:100% 40px, 100% 40px, 100% 14px, 100% 14px;background-attachment:local, local, scroll, scroll}.tableIcon.sc-digi-chart-line{--digi--icon--color:var(--digi--global--color--neutral--grayscale--darker);width:26px;height:26px;pointer-events:none}.tableIcon.sc-digi-chart-line:hover{--digi--icon--color:var(--digi--global--color--neutral--grayscale--darkest-3)}.tooltipBody.sc-digi-chart-line{display:flex;flex-direction:column;margin-right:5px}.topWrapper.sc-digi-chart-line{display:flex;flex-direction:row;align-items:flex-end;justify-content:space-between;flex-wrap:wrap}\";\nconst DigiChartLineStyle0 = chartLineCss;\n\nconst ChartLine = class {\n    constructor(hostRef) {\n        (0,_index_de760108_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);\n        this._lineTypes = [null, \"1.0, 7.0\", \"9.0, 7.0\"];\n        this._toggled = false;\n        this._tickSize = 0;\n        // Selection list from legend chips\n        this._selectedLines = [];\n        // Dragging\n        this._dragStart = 0;\n        this._dragDir = 0;\n        this._loading = false;\n        this.margin = {\n            bottom: 0,\n            top: 6,\n            left: 5,\n            right: 15\n        };\n        this.fontSize = '0.875rem';\n        this.xPadding = 5;\n        this.yPadding = 8;\n        this.xTickSize = 5;\n        // How many line types that exists currently\n        this.lineTypes = 3;\n        // Formats\n        this.formatStyle = ',d';\n        this.axisNumberFormat = {\n            decimal: ',',\n            thousands: ' ',\n            grouping: [3],\n            currency: ['', 'kr']\n        };\n        // Observer for watching size changes when in line chart mode\n        this.lineChartObserver = new ResizeObserver(entries => {\n            entries.forEach(() => {\n                this.resizeSvg();\n                this.resizeLines();\n                this.repositionTooltip(); // Called on both div.resize, and window.resize\n                (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._legendDiv).style('width', (this.dims.width) + 'px');\n            });\n        });\n        // Observer for watching size changes when in table mode\n        this.tableObserver = new ResizeObserver(entries => {\n            entries.forEach(() => {\n                (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._legendDiv).style('width', (this.dims.width) + 'px');\n                this.resizeTable();\n            });\n        });\n        this.dragStart = (e) => {\n            const container = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._legendDiv).node();\n            this._dragStart = e.x - container.offsetLeft;\n            this._scrollLeft = container.scrollLeft;\n        };\n        this.drag = (e) => {\n            const container = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._legendDiv);\n            this._dragDir = e.x;\n            const delta = this._dragDir - container.node().offsetLeft;\n            const walk = (delta - this._dragStart) * 1; //scroll-fast\n            container.property(\"scrollLeft\", this._scrollLeft - walk);\n        };\n        // Set yTicks\n        this.setYTicks = (init = false) => {\n            // Fixed number of y-axis lines\n            var step = this._chartData.meta && this._chartData.meta.numberOfReferenceLines\n                ? this._chartData.meta.numberOfReferenceLines\n                : 5, min = this._yAxis.domain()[0], max = this._yAxis.domain()[1], stepValue = (max - min) / (step - 1), tickValues = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.r)(min, max + stepValue, stepValue);\n            if (!init) {\n                this._yAxisHandle\n                    .style('font-size', this.fontSize)\n                    .transition()\n                    .duration(400)\n                    .call((0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.a)(this._yAxis)\n                    .ticks(step)\n                    .tickPadding(this.yPadding)\n                    .tickValues(tickValues)\n                    .tickSize(-(this.dims.width - this.margin.left))\n                    .tickFormat((d) => (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.axisNumberFormat).format(this.formatStyle)(d))).on('end', () => this.leftSetAxis());\n            }\n            else {\n                this._yAxisHandle\n                    .style('font-size', this.fontSize)\n                    .call((0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.a)(this._yAxis)\n                    .ticks(step)\n                    .tickPadding(this.yPadding)\n                    .tickValues(tickValues)\n                    .tickSize(-(this.dims.width - this.margin.left))\n                    .tickFormat((d) => (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.axisNumberFormat).format(this.formatStyle)(d)));\n            }\n            this._yAxisHandle\n                .selectAll('line')\n                .attr('stroke', getComputedStyle(document.documentElement)\n                .getPropertyValue('--digi--global--color--neutral--grayscale--darker')\n                .trim()\n                .toLocaleLowerCase());\n            this._yAxisHandle.select('.domain').attr('display', 'none');\n            if (init)\n                this.leftSetAxis(init);\n        };\n        // Adding event listeners to the chart\n        this.addListenersToChart = () => {\n            this._Tipbox.style('cursor', 'pointer')\n                .on('mousemove', this.drawTooltipLine)\n                .on('touchmove', 'ontouchstart' in window || window.navigator.maxTouchPoints ? this.drawTooltip : null)\n                .on('mouseup', this.drawTooltip)\n                .on('mouseleave', () => {\n                this._secondaryLine.attr('display', 'none');\n                if (!this._toggled) {\n                    this._TooltipLine.attr('display', 'none');\n                    this._Circles.selectAll('circle').attr('display', 'none');\n                }\n            });\n        };\n        // Initialize legend\n        this.initLegend = () => {\n            const container = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._legendDiv);\n            (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._legendDiv).style('width', (this.dims.width) + 'px');\n            container.selectAll('.chip').remove();\n            container.call(drag().on(\"start\", this.dragStart)\n                .on(\"drag\", this.drag));\n            container.selectAll('legendChips')\n                .data(this._chartData.data.series)\n                .join('button')\n                .attr('class', 'chip')\n                .attr('type', 'button')\n                .attr('aria-pressed', false)\n                .style('padding', '0.15rem 0.75rem')\n                .style('border', '2px solid white')\n                .style('border-radius', '6px')\n                .style('display', 'flex')\n                .style('flex-direction', 'row')\n                .style('gap', '0.5rem')\n                .style('align-items', 'center')\n                .style('flex-wrap', 'nowrap')\n                .style('min-width', 'fit-content')\n                .style('height', 'calc(2rem - 2px)')\n                .style('font-size', this.fontSize)\n                .style('white-space', 'nowrap')\n                .style('box-sizing', 'border-box')\n                .style('background-color', 'white')\n                .style('cursor', 'pointer')\n                .html((d) => {\n                return '<span style=\"pointer-events:none;\">' + d.title + '</span>';\n            })\n                .on('click', this.togglePath)\n                .on('mouseover', this.highlightPath)\n                .on('mouseleave', this.colorLines)\n                .datum((d) => d)\n                .insert('svg', 'span')\n                .attr('class', 'legendSvg')\n                .attr('pointer-events', 'none')\n                .attr('width', 32)\n                .attr('height', 28)\n                .append('line')\n                .attr('stroke', (d) => this.colorFunction(d))\n                .attr(\"stroke-linecap\", \"round\")\n                .attr('stroke-width', 6)\n                .attr('stroke-dasharray', (d, i) => this.dashFunction(d, i))\n                .attr('x1', 3)\n                .attr('x2', 29)\n                .attr('y1', '50%')\n                .attr('y2', '50%');\n            // Only if data contains many lines\n            if (this._chartData.data.series.length <= this.lineTypes)\n                return;\n            container.selectAll('.legendSvg')\n                .filter((...[, i]) => {\n                return i > 2;\n            })\n                .append('path')\n                .attr(\"d\", (...[, i]) => this.symbolType(i, 110))\n                .attr('fill', (d) => this.colorFunction(d))\n                .attr('transform', 'translate(16,14)');\n        };\n        // Highlights a line\n        this.highlightPath = (event, element) => {\n            if (event.target.className != 'chip')\n                return;\n            const target = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(event.target);\n            target.style('border', (d) => '2px solid ' + this.colorFunction(d));\n            this._lineChartContainer\n                .selectAll('.linePath')\n                .transition('highlight')\n                .duration(150)\n                .attr('stroke', (d, i, nodelist) => {\n                if (d.title === element.title) {\n                    (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(nodelist[i]).raise();\n                    return this.colorFunction(d);\n                }\n                else\n                    return '#E3E3E3';\n            });\n            this._lineChartContainer.selectAll('.symbolGroup')\n                .attr('fill', (d, i, nodelist) => {\n                if (d.title === element.title) {\n                    (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(nodelist[i]).raise();\n                }\n            });\n            this._lineChartContainer.selectAll('.symbolGroup')\n                .selectAll('.symbol')\n                .transition('highlight')\n                .duration(150)\n                .attr('fill', (d) => {\n                if (!d)\n                    return;\n                if (d.title === element.title) {\n                    return this.colorFunction(d);\n                }\n                else\n                    return '#E3E3E3';\n            });\n        };\n        // Selecting a path to view sollely from legend\n        this.togglePath = (event) => {\n            if (event.target.className != 'chip')\n                return;\n            const target = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(event.target);\n            // Using color of text to identify what state the legend chip is in, so resetting this the last thing we do\n            const swap = 'white' === target.style('color');\n            target.style('border', (d) => '2px solid ' + this.colorFunction(d))\n                .style('background-color', (d) => swap ? 'white' : this.colorFunction(d))\n                .style('color', () => swap ? 'black' : 'white')\n                .attr('aria-pressed', target.attr('aria-pressed') == 'false' ? true : false)\n                .select('line')\n                .attr('stroke', (d) => swap ? this.colorFunction(d) : 'white');\n            target.select('path').attr('fill', (d) => swap ? this.colorFunction(d) : 'white');\n            if (swap) {\n                this._selectedLines = this._selectedLines.filter(elem => {\n                    return elem.title === target.datum()['title'] ? false : true;\n                });\n            }\n            else {\n                this._selectedLines.push(this._coreSeries.filter(elem => elem.title === target.datum()['title'])[0]);\n            }\n            if (this._selectedLines.length < 1)\n                this._chartData.data.series = JSON.parse(JSON.stringify(this._coreSeries));\n            else {\n                this._chartData.data.series.map((serie) => {\n                    const index = this._selectedLines.findIndex((selected) => {\n                        return serie.title === selected.title;\n                    });\n                    if (index != -1) {\n                        serie.yValues = this._selectedLines[index].yValues;\n                    }\n                    else {\n                        serie.yValues = [];\n                    }\n                });\n            }\n            this.updateSvg();\n        };\n        // Coloring all lines\n        this.colorLines = (event) => {\n            const target = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(event.target);\n            target.style('border', '2px solid white');\n            this._lineChartContainer\n                .selectAll('.linePath')\n                .transition('highlight')\n                .duration(150)\n                .attr('stroke', (d) => this.colorFunction(d));\n            this._lineChartContainer.selectAll('.symbolGroup')\n                .selectAll('.symbol')\n                .transition('highlight')\n                .duration(150)\n                .attr('fill', (d) => d ? this.colorFunction(d) : null);\n        };\n        // Returns a line type given a integer value\n        this.dashFunction = (...[, index]) => {\n            return this._lineTypes[index % this._lineTypes.length];\n        };\n        // Initialize the drawing of the lines\n        this.initLines = () => {\n            this.defineLineAndScale();\n            // TODO: do this data appending somewhere else\n            this._lineChartContainer\n                .selectAll('linePath')\n                .data(this.reshapeData(this._chartData.data.series))\n                .join('path')\n                .attr('class', 'linePath')\n                .attr('stroke', (d) => this.colorFunction(d))\n                .attr(\"stroke-linecap\", \"round\")\n                .attr('stroke-width', (d) => d.length > 1 ? 4 : 6)\n                .attr('stroke-dasharray', (d, i) => d.length > 1 ? this.dashFunction(d, i) : null)\n                .attr('fill', 'none')\n                .attr('d', (d) => this._LineFunc(d.line));\n            this.addSymbols();\n        };\n        this.defineLineAndScale = () => {\n            this._LineFunc = line()\n                .defined((d) => d[1] != null && d[1] != undefined && !isNaN(d[1]))\n                .x((d) => this._lineScale(d[0]))\n                .y((d) => this._yAxis(d[1]));\n        };\n        // Modifies data object adds a line member to object, line is an array of pairs of number: [number, number][]\n        // Line is used to feed into _LineFunc\n        this.reshapeData = (series) => {\n            return series.map((obj) => {\n                obj.line = this._chartData.data.xValues.map((elem, ind) => {\n                    return [elem, obj.yValues[ind]];\n                });\n                obj.length = obj.yValues.filter((e) => e != null && e != undefined).length;\n                return obj;\n            });\n        };\n        // Adding symbols to lines where needed\n        this.addSymbols = (transition = false) => {\n            // Remove all old symbols\n            this._lineChartContainer.selectAll('.symbolGroup')\n                .data(this.reshapeData(this._chartData.data.series.filter((...[, index]) => index > 2)))\n                .join(enter => {\n                if (!transition) {\n                    enter.append('g')\n                        .attr('class', 'symbolGroup')\n                        .selectAll('symbols')\n                        .data((d, i) => {\n                        return d.line.map((num) => {\n                            if (num[1] != null)\n                                return { val: num[1], x: num[0], title: d.title, colorToken: d.colorToken, index: i };\n                            else\n                                return null;\n                        });\n                    })\n                        .join('path')\n                        .attr('class', 'symbol')\n                        .attr(\"d\", (d) => d ? this.symbolType(d.index) : null)\n                        .attr('fill', (d) => d ? this.colorFunction(d) : null)\n                        .attr('transform', (d) => d ? `translate(${this._lineScale(d.x)},${this._yAxis(d.val)})` : null);\n                }\n                else {\n                    enter.append('g')\n                        .attr('class', 'symbolGroup')\n                        .selectAll('symbol')\n                        .data((d, i) => {\n                        return d.line.map((num) => {\n                            if (num[1] != null)\n                                return { val: num[1], x: num[0], title: d.title, colorToken: d.colorToken, index: i };\n                            else\n                                return null;\n                        });\n                    })\n                        .join('path')\n                        .attr('class', 'symbol')\n                        .attr(\"d\", (d) => d ? this.symbolType(d.index) : null)\n                        .attr('fill', (d) => d ? this.colorFunction(d) : null)\n                        .attr('transform', (d) => d ? `translate(${this._lineScale(d.x)},${this._yAxis(d.val)})` : null);\n                }\n            }, update => {\n                if (!transition) {\n                    update.selectAll('.symbol')\n                        .data((d, i) => {\n                        return d.line.map((num) => {\n                            if (num[1] != null)\n                                return { val: num[1], x: num[0], title: d.title, colorToken: d.colorToken, index: i };\n                            else\n                                return null;\n                        });\n                    })\n                        .join('path')\n                        .attr('class', 'symbol')\n                        .attr(\"d\", (d) => d ? this.symbolType(d.index) : null)\n                        .attr('fill', (d) => d ? this.colorFunction(d) : null)\n                        .attr('transform', (d) => d ? `translate(${this._lineScale(d.x)},${this._yAxis(d.val)})` : null);\n                }\n                else {\n                    update.selectAll('path')\n                        .data((d, i) => {\n                        const toReturn = d.line.map((num) => {\n                            if (num[1] != null)\n                                return { val: num[1], x: num[0], title: d.title, colorToken: d.colorToken, index: i };\n                            else\n                                return null;\n                        });\n                        return toReturn.filter(e => e);\n                    })\n                        .join(enter => {\n                        enter.append('path').attr('class', 'symbol')\n                            .attr(\"d\", (d) => d ? this.symbolType(d.index) : null)\n                            .attr('fill', (d) => d ? this.colorFunction(d) : null)\n                            .attr('transform', (d) => d ? `translate(${this._lineScale(d.x)},${this._yAxis(d.val)})` : null)\n                            .attr('opacity', 0)\n                            .transition()\n                            .duration(400)\n                            .ease(_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.p)\n                            .attr('opacity', 1);\n                    }, update => {\n                        update\n                            .transition()\n                            .duration(400)\n                            .ease(_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.p)\n                            .attr(\"d\", (d) => d ? this.symbolType(d.index) : null)\n                            .attr('fill', (d) => d ? this.colorFunction(d) : null)\n                            .attr('transform', (d) => d ? `translate(${this._lineScale(d.x)},${this._yAxis(d.val)})` : null);\n                    }, exit => exit.remove());\n                }\n            }, exit => exit.remove());\n        };\n        // Returns a symbol type given a index, currently we have support for 10 lines\n        this.symbolType = (index, size) => {\n            if (index < this.lineTypes)\n                return Symbol().type(circle).size(size ? size : 90)();\n            else if (index >= this.lineTypes && index < (this.lineTypes * 2))\n                return Symbol().type(diamond).size(size ? size : 90)();\n            else\n                return Symbol().type(star).size(size ? size : 90)();\n        };\n        // Setting dimension variable\n        this.setDims = (onlyHeight = false) => {\n            // Get title dimensions\n            const tempTitle = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._titleDiv).node().getBoundingClientRect(), tempLegend = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._legendDiv).node().getBoundingClientRect();\n            const rem = parseFloat(getComputedStyle(document.documentElement).fontSize);\n            if (!onlyHeight)\n                this.dims = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._chartDiv).node().getBoundingClientRect();\n            this.dims.height = this._maxHeight - tempLegend.height - tempTitle.height - (1.75 * rem);\n        };\n        // Resizing svg element and its children\n        this.resizeSvg = () => {\n            if (this._loading)\n                return this.loadingResize();\n            this.setDims();\n            this._svg.attr('width', this.dims.width).attr('height', this.dims.height);\n            /****  Update yAxis ****/\n            this._yAxis.range([this.dims.height - this.margin.bottom, this.margin.top]);\n            // Fixed number of y-axis lines\n            this.setYTicks(true);\n            /****  Update xAxis ****/\n            this._xAxis.range([0, this.dims.width - this.margin.left - this.margin.right]);\n            const ticks = Math.min(Math.max(Math.floor((this.dims.width - this.margin.left - this.margin.right) / this._tickSize) - 2, 1), this._chartData.data.xValues.length);\n            this._xAxisHandle\n                .attr('transform', 'translate(0,' + (this.dims.height - this.margin.bottom) + ')')\n                .call((0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.b)(this._xAxis)\n                .ticks(ticks)\n                .tickPadding(this.xPadding)\n                .tickFormat((d) => {\n                if (this._chartData.data.xValueNames)\n                    return this._chartData.data.xValueNames[this._chartData.data.xValues.indexOf(d)];\n                else\n                    return d;\n            }));\n            this._Tipbox.attr('width', this.dims.width - this.margin.left / 2)\n                .attr('height', this.dims.height - this.margin.top - this.margin.bottom)\n                .attr('transform', `translate(${this.margin.left / 2},${this.margin.top})`);\n        };\n        // resizing chart while loading\n        this.loadingResize = () => {\n            this.setDims();\n            this._svg.attr('width', this.dims.width);\n            this.setYTicks();\n            this._xAxis.range([0, this.dims.width - this.margin.left - this.margin.right]);\n            const ticks = Math.min(Math.floor((this.dims.width - this.margin.left - this.margin.right) / this._tickSize) - 2, this._xAxis.domain()[1]);\n            this._xAxisHandle\n                .call((0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.b)(this._xAxis)\n                .ticks(ticks)\n                .tickPadding(this.xPadding)\n                .tickFormat((d) => {\n                if (this._chartData.data && this._chartData.data.xValueNames)\n                    return this._chartData.data.xValueNames[this._chartData.data.xValues.indexOf(d)];\n                else\n                    return d;\n            }));\n            this._lineScale.range([0, this.dims.width - this.margin.left - this.margin.right]);\n            const LineFunc = line()\n                .defined((d) => d[1] != null)\n                .x((d) => this._lineScale(d[0]))\n                .y((d) => this._yAxis(d[1]))\n                .curve(basis);\n            this._lineChartContainer.selectAll('.linePath')\n                .attr('d', (d) => LineFunc(d));\n        };\n        this.resizeLines = () => {\n            if (this._loading)\n                return;\n            this._lineScale.range([0, this.dims.width - this.margin.left - this.margin.right]);\n            this.defineLineAndScale();\n            this._lineChartContainer\n                .selectAll('.linePath')\n                .attr('stroke', (d) => this.colorFunction(d))\n                .attr('d', (d) => this._LineFunc(d.line));\n            this._lineChartContainer.selectAll('.symbolGroup')\n                .selectAll('.symbol')\n                .attr('transform', (d, i) => d ? `translate(${this._lineScale(this._chartData.data.xValues[i])},${this._yAxis(d.val)})` : null);\n        };\n        this.colorFunction = (properties) => {\n            return properties.colorToken\n                ? getComputedStyle(document.documentElement)\n                    .getPropertyValue(properties.colorToken)\n                    .trim()\n                    .toLocaleLowerCase()\n                : this._Color(properties.title);\n        };\n        this.drawTooltipLine = (event) => {\n            if (this._toggled)\n                return this.drawDottedLine(event);\n            this.drawMainLineAndCircles(event);\n        };\n        this.closeTooltip = () => {\n            this._toggled = false;\n            this._tooltip.style('display', 'none');\n            this._secondaryLine.attr('display', 'none');\n            this._TooltipLine.attr('display', 'none');\n            this._Circles.selectAll('circle').attr('display', 'none');\n            this._Circles\n                .selectAll('circle')\n                .attr('fill', 'white')\n                .attr('stroke', (d) => this.colorFunction(d));\n            this._svg.select('.tooltipPointer').remove();\n        };\n        this.drawDottedLine = (event) => {\n            this._hoverPoint = this.closest(Math.round(this._lineScale.invert(pointer(event, this._Tipbox.node())[0] - (this.margin.left / 2))));\n            if (this._hoverPoint === this._tooltipPoint)\n                return this._secondaryLine.attr(\"display\", \"none\");\n            this._secondaryLine\n                .attr(\"display\", null)\n                .attr('stroke', 'gray')\n                .attr(\"stroke-dasharray\", 4)\n                .attr('x1', this._xAxis(this._hoverPoint.toString()) + this.margin.left)\n                .attr('x2', this._xAxis(this._hoverPoint.toString()) + this.margin.left)\n                .attr('y1', this._yAxis(this._maxVal))\n                .attr('y2', this.dims.height - this.margin.bottom)\n                .style('pointer-events', 'none');\n        };\n        this.drawMainLineAndCircles = (event) => {\n            this._hoverPoint = this.touchPosition(event);\n            const stringPoint = this._hoverPoint.toString();\n            this._TooltipLine\n                .attr('display', null)\n                .attr('stroke', 'gray')\n                .attr('x1', this._xAxis(stringPoint) + this.margin.left)\n                .attr('x2', this._xAxis(stringPoint) + this.margin.left)\n                .attr('y1', this._yAxis(this._maxVal))\n                .attr('y2', this.dims.height - this.margin.bottom)\n                .style('pointer-events', 'none');\n            this._Circles\n                .selectAll('circle')\n                .attr('display', null)\n                .attr('pointer-events', 'none');\n            this.positionCircles(stringPoint);\n        };\n        // Returns the position/index to draw tooltip/tooltip line\n        this.touchPosition = (event) => {\n            if (event.type === 'touchmove') {\n                event.preventDefault();\n                return this.closest(Math.round(this._lineScale.invert(pointer(event.touches[0], this._Tipbox.node())[0] - (this.margin.left / 2))));\n            }\n            else {\n                return this.closest(Math.round(this._lineScale.invert(pointer(event, this._Tipbox.node())[0] - (this.margin.left / 2))));\n            }\n        };\n        // Function for drawing tooltip\n        this.drawTooltip = (event) => {\n            this.drawMainLineAndCircles(event);\n            this._toggled = true;\n            this._tooltipPoint = this.touchPosition(event);\n            this._tooltipDataIndex = this._chartData.data.xValues.indexOf(this._tooltipPoint);\n            // Heading\n            this._tooltip.style('display', 'flex');\n            let tooltipBody = this._tooltip.select(\".tooltipBody\");\n            tooltipBody.select(this._tooltipHeading)\n                .style('margin', '0 0.75rem 0 0 ')\n                .html(() => {\n                if (this._chartData.data.xValueNames)\n                    return this._chartData.data.xValueNames[this._chartData.data.xValues.indexOf(this._tooltipPoint)];\n                return this._tooltipPoint;\n            });\n            // Body\n            tooltipBody\n                .selectAll('div')\n                .data(this._chartData.data.series)\n                .join('div')\n                .style(\"display\", \"flex\")\n                .style(\"flex-direction\", \"row\")\n                .style(\"flex-wrap\", \"nowrap\")\n                .style(\"white-space\", \"nowrap\")\n                .style(\"justify-content\", \"space-between\")\n                .html((d) => {\n                return d.yValues[this._tooltipDataIndex] != null ? '<span>' + d.title + '</span><span style=\"margin-left:0.75rem;\">' + (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.axisNumberFormat).format(this.formatStyle)(d.yValues[this._tooltipDataIndex]) + '</span>' : null;\n            });\n            this.positionTooltipWithinBounds(this._xAxis(this._tooltipPoint.toString()) + this.margin.left);\n            this._Circles\n                .selectAll('circle')\n                .attr('fill', (d) => this.colorFunction(d))\n                .attr('stroke', 'white');\n            this._svg.select('.tooltipPointer').remove();\n            const sym = Symbol().type(triangle).size(60);\n            this._svg.append(\"path\")\n                .attr(\"d\", sym)\n                .attr('class', 'tooltipPointer')\n                .attr(\"fill\", \"rgba(10, 10, 10, 0.90)\")\n                .style('filter', 'drop-shadow(gray 0px -1px 1px)')\n                .attr(\"transform\", `translate(${this._xAxis(this._tooltipPoint.toString()) + this.margin.left},${this._yAxis(this._maxVal) - 7}) rotate(180) scale(1.5,1.0)`);\n        };\n        this.initYAxis = (empty) => {\n            // Y Axis\n            this._yAxis = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.l)()\n                .domain([0, empty ? 10 : this._maxVal])\n                .nice(3)\n                .range([this.dims.height - this.margin.bottom, this.margin.top]);\n            // The magic number is just needed in initialization, because getting the exact size is impossible during the initialization\n            this.margin.left = this.getTextSize((0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.axisNumberFormat).format(this.formatStyle)(this._yAxis.domain()[1])) + this.yPadding + 3;\n            this._lineChartContainer = this._svg\n                .append('g')\n                .attr('transform', `translate(${this.margin.left},0)`);\n            this._yAxisHandle = this._lineChartContainer\n                .append('g')\n                .attr('class', 'yAxis');\n            this.setYTicks(true);\n        };\n        this.initXAxis = (empty) => {\n            this._lineChartContainer.select('.xAxis').remove();\n            // X axis\n            if (!empty) {\n                if (this._chartData.data.xValueNames)\n                    this.margin.right = (this.getTextSize(this._chartData.data.xValueNames[this._chartData.data.xValueNames.length - 1]) / 2) + 1;\n                else\n                    this.margin.right = this.getTextSize((0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.m)(this._chartData.data.xValues).toString()) / 2 + 1;\n            }\n            this._xAxis = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.l)()\n                .domain([\n                empty ? 1 : (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.d)(this._chartData.data.xValues),\n                empty ? 10 : (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.m)(this._chartData.data.xValues)\n            ]) // This is the min and the max of the data\n                .range([0, this.dims.width - this.margin.left - this.margin.right]);\n            this._lineScale = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.l)()\n                .domain([\n                empty ? 1 : (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.d)(this._chartData.data.xValues),\n                empty ? 10 : (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.m)(this._chartData.data.xValues)\n            ]) // This is the min and the max of the data\n                .range([0, this.dims.width - this.margin.left - this.margin.right]);\n            const ticks = Math.min(Math.max(Math.floor((this.dims.width - this.margin.left - this.margin.right) / this._tickSize) - 2, 2), empty ? 10 : this._chartData.data.xValues.length);\n            this._xAxisHandle = this._lineChartContainer\n                .append('g')\n                .attr('transform', 'translate(0,' + (this.dims.height - this.margin.bottom) + ')')\n                .attr('class', 'xAxis')\n                .style('font-size', this.fontSize)\n                .call((0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.b)(this._xAxis)\n                .ticks(ticks)\n                .tickSize(this.xTickSize)\n                .tickPadding(this.xPadding)\n                .tickFormat((d) => {\n                if (!empty && this._chartData.data.xValueNames)\n                    return this._chartData.data.xValueNames[this._chartData.data.xValues.indexOf(d)];\n                else\n                    return d;\n            }));\n            // Removing the domain\n            this._xAxisHandle.select('.domain').attr(\"display\", \"none\");\n            this._xAxisHandle\n                .selectAll('line')\n                .attr(\"stroke-linecap\", \"round\")\n                .attr('stroke', getComputedStyle(document.documentElement)\n                .getPropertyValue('--digi--global--color--neutral--grayscale--darkest-3')\n                .trim()\n                .toLocaleLowerCase());\n        };\n        this.positionCircles = (point, transition) => {\n            if (transition) {\n                this._Circles.selectAll('circle')\n                    .transition('positioncircles')\n                    .duration(transition)\n                    .attr('cx', () => {\n                    return this._xAxis(point) + this.margin.left;\n                })\n                    .attr('cy', (d, i, circleList) => {\n                    let selData = d.yValues[this._chartData.data.xValues.indexOf(parseInt(point))];\n                    if (this._yAxis(selData))\n                        return this._yAxis(selData);\n                    else {\n                        (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(circleList[i]).attr('display', 'none');\n                        return null;\n                    }\n                });\n            }\n            else {\n                this._Circles.selectAll('circle')\n                    .attr('cx', () => {\n                    return this._xAxis(point) + this.margin.left;\n                })\n                    .attr('cy', (d, i, circleList) => {\n                    let selData = d.yValues[this._chartData.data.xValues.indexOf(parseInt(point))];\n                    if (this._yAxis(selData))\n                        return this._yAxis(selData);\n                    else {\n                        (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(circleList[i]).attr('display', 'none');\n                        return null;\n                    }\n                });\n            }\n        };\n        this.repositionTooltip = () => {\n            if (!this._toggled)\n                return;\n            const stringPoint = this._chartData.data.xValues[this._tooltipDataIndex].toString();\n            this._TooltipLine.attr('stroke', 'gray')\n                .attr('x1', this._xAxis(stringPoint) + this.margin.left)\n                .attr('x2', this._xAxis(stringPoint) + this.margin.left)\n                .attr('y1', this._yAxis(this._maxVal))\n                .attr('y2', this.dims.height - this.margin.bottom);\n            this.positionTooltipWithinBounds(this._xAxis(stringPoint) + this.margin.left);\n            this._svg.select('.tooltipPointer').attr(\"transform\", `translate(${this._xAxis(this._tooltipPoint.toString()) + this.margin.left},${this._yAxis(this._maxVal) - 7}) rotate(180) scale(1.5,1.0)`);\n            this.positionCircles(stringPoint);\n        };\n        // Checks if tooltip bounding box is outside svg width, if so, moves tooltip within svg bounds\n        this.positionTooltipWithinBounds = (pos, transitionTimer) => {\n            this._tooltip\n                .style('transform', () => {\n                // We reset the position of the tooltip, and adjust for the maximum value, -1px for it to align perfectly\n                return `translateY(${this._yAxis(this._maxVal) - this._tooltip.node().getBoundingClientRect().height - 9}px)`;\n            });\n            const rect = this._chartDiv.getBoundingClientRect();\n            const comparativePosition = pos + rect.left;\n            const tooltipWidth = (this._tooltip.node().getBoundingClientRect().width) / 2;\n            if (rect.left < comparativePosition - tooltipWidth && rect.right > comparativePosition + tooltipWidth) {\n                this._tooltip.style('left', pos - tooltipWidth + 'px');\n            }\n            else if (rect.right < comparativePosition + tooltipWidth) {\n                this._tooltip.style(\"left\", pos - this._tooltip.node().getBoundingClientRect().width + Math.max(this.margin.right, 10) + 'px');\n            }\n            else if (rect.left > comparativePosition - tooltipWidth) {\n                if (transitionTimer)\n                    this._tooltip.transition('moveTooltip').duration(transitionTimer).ease(_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.p).style(\"left\", pos - this.margin.left + 'px');\n                else\n                    this._tooltip.style(\"left\", pos - this.margin.left + 'px');\n            }\n            else {\n                this._tooltip.style('left', pos - (document.getElementById(this.afId).getBoundingClientRect().width / 2) + 'px');\n            }\n        };\n        this.mapColorToLine = () => {\n            // list of group names\n            this._Color = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.o)()\n                .domain(this._chartData.data.series.map(function (d) {\n                return d.title;\n            }))\n                .range([\n                '#00005a',\n                '#D43372',\n                '#058470',\n                '#0058A3',\n                '#556D22',\n                '#1616B2',\n                '#AA295B',\n                '#035548'\n            ]);\n        };\n        this.computeMaxVal = () => {\n            // Compute max value from datasets\n            this._maxVal = parseFloat((0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.m)(this._chartData.data.series, (d) => (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.m)(d['yValues'])));\n        };\n        // Updates number format if specified to be in percentage\n        this.checkPercentage = () => {\n            if (this._chartData.meta && this._chartData.meta.percentage)\n                this.formatStyle = '.1%';\n            else\n                this.formatStyle = ',d';\n        };\n        this.closest = (target) => {\n            return this._chartData.data.xValues.reduce(function (prev, curr) {\n                return (Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev);\n            });\n        };\n        // Removes resize observer for chart and inits table\n        this.activateTable = (event) => {\n            this.closeTooltip();\n            this.lineChartObserver.disconnect();\n            this.tableObserver.observe(this._chartDiv);\n            this._status.innerHTML = '<p>Visas som tabell</p>';\n            (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._host).select('.tableButton').style('display', 'none');\n            (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._host).select('.chartButton').style('display', null);\n            event.target.nextSibling.lastChild.focus();\n            const duration = 150;\n            this._svg\n                .attr('opacity', 1)\n                .transition('fadeout')\n                .duration(duration)\n                .attr('opacity', 0)\n                .on('end', () => {\n                this._svg.remove();\n                this._legendDiv.style['display'] = 'none';\n                this._tableDiv.style['display'] = 'block';\n                this.setTableContent();\n                this.setTableDimensions();\n                (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._tableDiv).style('opacity', 0)\n                    .transition('fadein')\n                    .duration(duration)\n                    .style('opacity', 1);\n            });\n            (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._legendDiv).style('opacity', 1)\n                .transition('fadeout')\n                .duration(duration)\n                .style('opacity', 0);\n        };\n        // Resize table\n        this.resizeTable = () => {\n            this.setDims();\n            this.setTableDimensions();\n        };\n        // Removes observer and calls init functions for line chart\n        this.reInitChart = (event) => {\n            this.tableObserver.disconnect();\n            this._status.innerHTML = '<p>Visas som diagram</p>';\n            (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._host).select('.tableButton').style('display', null);\n            (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._host).select('.chartButton').style('display', 'none');\n            event.target.previousSibling.lastChild.focus();\n            const table = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._tableDiv);\n            table.style('opacity', 1)\n                .transition()\n                .duration(150)\n                .style('opacity', 0)\n                .on('end', () => {\n                table.style('display', 'none');\n                this.initSvg();\n                this.initLines();\n                this._svg\n                    .attr('opacity', 0)\n                    .transition()\n                    .duration(150)\n                    .attr('opacity', 1);\n                (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._legendDiv)\n                    .style('display', null)\n                    .style('opacity', 0)\n                    .transition()\n                    .duration(150)\n                    .style('opacity', 1);\n            });\n        };\n        this.afHeadingLevel = undefined;\n        this.afId = (0,_randomIdGenerator_util_9cf19c59_js__WEBPACK_IMPORTED_MODULE_3__.r)('tooltip');\n        this.afChartData = undefined;\n    }\n    afChartDataUpdate() {\n        let data = this.afChartData;\n        if (typeof data === 'object') {\n            this._chartData = Object.assign({}, data);\n            return;\n        }\n        this._chartData = JSON.parse(data);\n        // Making deep copy of this\n        if (this._chartData.data)\n            this._coreSeries = (JSON.parse(JSON.stringify(this._chartData.data.series)));\n    }\n    initSvg() {\n        this.margin.bottom = (Number(window.getComputedStyle(document.body).getPropertyValue('font-size').match(/\\d+/)[0]) * Number(this.fontSize.replace(/[^\\d.]|\\.(?=.*\\.)/g, ''))) + this.xPadding + this.xTickSize;\n        this.lineChartObserver.observe(this._chartDiv);\n        (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._chartDiv).select('svg').remove();\n        // Initialize an empty div, that we can place info in for tooltip\n        // Styling for tooltip is in .scss file\n        this._tooltip = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(\"#\" + this.afId);\n        this._tooltip.select('.close').on(\"click\", this.closeTooltip);\n        this._tooltipHeading = 'h' + (parseInt(this.afHeadingLevel.replace(/\\D/g, \"\")) + 1);\n        // Add heading placeholder for heading\n        this._tooltip.selectAll(\".tooltipBody\")\n            .append(this._tooltipHeading) // increment heading level by one\n            .style('margin', '0 0.75rem')\n            .style('font-weight', '500');\n        this._maxHeight = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._host).node().parentNode.getBoundingClientRect().height;\n        this.setDims();\n        this.setTickSize();\n        this.checkPercentage();\n        (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._chartDiv).attr(\"height\", this.dims.height + 'px');\n        // Appending svg\n        this._svg = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._chartDiv).append('svg')\n            .attr('aria-hidden', true)\n            .attr('role', 'img')\n            .attr('aria-label', this._chartData && this._chartData.title ? 'Linjediagram om ' + this._chartData.title.toLowerCase() : 'Linjediagram');\n        this._svg.attr('width', this.dims.width).attr('height', this.dims.height);\n        this.mapColorToLine();\n        this._TooltipLine = this._svg\n            .append('line')\n            .attr('id', 'toolTipLine' + this.afId);\n        this._secondaryLine = this._svg\n            .append('line')\n            .attr('id', 'secondaryLine' + this.afId);\n        this.computeMaxVal();\n        this.initYAxis();\n        this.initXAxis();\n        this._Tipbox = this._svg\n            .append('rect')\n            .attr('class', 'svgRect')\n            .attr('width', this.dims.width - (this.margin.left / 2))\n            .attr('height', this.dims.height - this.margin.top - this.margin.bottom)\n            .attr('opacity', 0)\n            .attr('transform', `translate(${this.margin.left / 2},0)`);\n        this.addListenersToChart();\n        this._Circles = this._svg.append('g').attr('class', 'circleGroup').on('mousemove', this.drawTooltipLine);\n        this._Circles\n            .selectAll('circle')\n            .data(this._chartData.data.series)\n            .join('circle')\n            .attr('stroke', (d) => this.colorFunction(d))\n            .attr('fill', 'white')\n            .attr('stroke-width', '1px')\n            .attr('r', 7)\n            .attr('display', 'none');\n        (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(window).on(\"resize.\" + this.afId, this.repositionTooltip);\n    }\n    // Initializing chart with empty dataset\n    initEmpty() {\n        this.margin.bottom = (Number(window.getComputedStyle(document.body).getPropertyValue('font-size').match(/\\d+/)[0]) * Number(this.fontSize.replace(/[^\\d.]|\\.(?=.*\\.)/g, ''))) + this.xPadding + this.xTickSize;\n        (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._chartDiv).select('svg').remove();\n        // Initialize an empty div, that we can place info in for tooltip\n        // Styling for tooltip is in .scss file\n        this._tooltip = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(\"#\" + this.afId);\n        (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)('digi-icon-x').on(\"click\", this.closeTooltip);\n        this._tooltipHeading = 'h' + (parseInt(this.afHeadingLevel.replace(/\\D/g, \"\")) + 1);\n        // Add heading placeholder for heading\n        this._tooltip.selectAll(\".tooltipBody\")\n            .append(this._tooltipHeading) // increment heading level by one\n            .style('margin', '0 0.75rem')\n            .style('font-weight', '500');\n        this._maxHeight = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._host).node().parentNode.getBoundingClientRect().height;\n        this.setDims();\n        (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._chartDiv).attr(\"height\", this.dims.height + 'px');\n        this._svg = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._chartDiv).append('svg').attr('aria-hidden', true);\n        this._svg.attr('width', this.dims.width).attr('height', this.dims.height);\n        this._TooltipLine = this._svg\n            .append('line')\n            .attr('id', 'toolTipLine' + this.afId);\n        this._secondaryLine = this._svg\n            .append('line')\n            .attr('id', 'secondaryLine' + this.afId);\n        this.initYAxis(true);\n        this.initXAxis(true);\n        this._Tipbox = this._svg\n            .append('rect')\n            .attr('class', 'svgRect')\n            .attr('width', this.dims.width - this.margin.left / 2)\n            .attr('height', this.dims.height - this.margin.top - this.margin.bottom)\n            .attr('opacity', 0)\n            .attr('transform', `translate(${this.margin.left / 2},0)`);\n        this._Circles = this._svg.append('g').attr('class', 'circleGroup').on('mousemove', this.drawTooltipLine);\n        this.defineLineAndScale();\n        this.lineChartObserver.observe(this._chartDiv);\n        this.loadingState(true);\n    }\n    loadingState(empty) {\n        this._loading = true;\n        (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)('.tableButton').style('display', 'none');\n        const duration = 400;\n        const LineFunc = line()\n            .defined((d) => d[1] != null)\n            .x((d) => this._lineScale(d[0]))\n            .y((d) => this._yAxis(d[1]))\n            .curve(basis);\n        // close potentially open tooltip\n        this.closeTooltip();\n        // Remove hover listeners from chart\n        this._Tipbox.style('cursor', 'wait')\n            .on('mousemove', null)\n            .on('touchmove', null)\n            .on('mouseup', null)\n            .on('mouseleave', null);\n        (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._titleDiv).select(this.afHeadingLevel).html(`${_text_f08f550e_js__WEBPACK_IMPORTED_MODULE_1__._.loading}...`);\n        const height = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._titleDiv).style('height');\n        (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._titleDiv)\n            .style('height', this._prevHeight)\n            .transition('adjust')\n            .duration(400)\n            .style('height', height)\n            .on('end', () => (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._titleDiv).style('height', null));\n        (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._legendDiv).style('display', 'none');\n        let animateRandomLine = () => {\n            let firstVal = this._xAxis.domain()[0];\n            const randomData = [...Array(this._xAxis.domain()[1])].map(() => {\n                const dataPoint = [firstVal, Math.round((Math.random() * this._yAxis.domain()[1]) * 100) / 100]; // This assumes domain is from 0 to maxVal\n                firstVal++;\n                return dataPoint;\n            });\n            this._lineChartContainer.selectAll('.linePath').remove();\n            this._lineChartContainer.selectAll('linePath')\n                .data([randomData])\n                .join('path')\n                .attr('class', 'linePath')\n                .attr('stroke', 'lightgray')\n                .attr(\"stroke-linecap\", \"round\")\n                .attr('stroke-width', 4)\n                .attr('fill', 'none')\n                .attr('d', (d) => LineFunc(d))\n                .transition()\n                .duration(duration * 3)\n                .ease(quadInOut)\n                .attrTween(\"stroke-dasharray\", function () {\n                const length = this.getTotalLength();\n                return (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.c)(`0,${length}`, `${length},${length}`);\n            })\n                .on('end', () => {\n                this._lineChartContainer.selectAll('.linePath').attr(\"stroke-dasharray\", function () {\n                    const length = this.getTotalLength();\n                    return length + \" \" + length;\n                })\n                    .attr(\"stroke-dashoffset\", 0)\n                    .transition().duration(duration * 3).ease(quadInOut)\n                    .attr(\"stroke-dashoffset\", function () {\n                    return -this.getTotalLength();\n                })\n                    .on('end', () => animateRandomLine());\n            });\n        };\n        let flattenLines = () => {\n            const data = this._lineChartContainer.selectAll('.linePath').data().map((elem) => {\n                elem.line = elem.line.map((point) => {\n                    return point[1] ? [point[0], this._yAxis.domain()[0]] : [point[0], undefined];\n                });\n                return elem;\n            });\n            this._lineChartContainer.selectAll('.linePath')\n                .data(data)\n                .transition()\n                .duration(duration)\n                .ease(_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.p)\n                .attr('d', (d) => this._LineFunc(d.line))\n                .on('end', (...[, i]) => i === 0 ? animateRandomLine() : null);\n            this._lineChartContainer.selectAll('.symbolGroup')\n                .selectAll('.symbol')\n                .transition().duration(duration).ease(_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.e)\n                .attr('transform', (d) => d ? `translate(${this._lineScale(d.x)},${this._yAxis(this._yAxis.domain()[0])})` : null)\n                .attr('opacity', 0);\n        };\n        // Start loadingstate, either from empty set or last set\n        if (empty)\n            animateRandomLine();\n        else\n            flattenLines();\n    }\n    updateSvg() {\n        // displaying legend again\n        if (this._loading) {\n            (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._host).select('.tableButton').style('display', null);\n            (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._legendDiv).style('display', null);\n            (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._titleDiv).style('height', null);\n        }\n        if (this._chartData.data.xValueNames)\n            this.margin.right = (this.getTextSize(this._chartData.data.xValueNames[this._chartData.data.xValueNames.length - 1]) / 2) + 1;\n        else\n            this.margin.right = this.getTextSize((0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.m)(this._chartData.data.xValues).toString()) / 2 + 1;\n        this.checkPercentage();\n        this.setDims(true);\n        this.mapColorToLine();\n        this.computeMaxVal();\n        this.setTickSize();\n        (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._chartDiv).attr(\"height\", this.dims.height + 'px');\n        // Updating Svg attributes\n        this._svg.attr('width', this.dims.width + 'px')\n            .attr('height', this.dims.height + 'px')\n            .attr('aria-label', this._chartData && this._chartData.title ? 'Linjediagram om ' + this._chartData.title.toLowerCase() : 'Linjediagram');\n        // Y Axis\n        this._yAxis = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.l)()\n            .domain([0, this._maxVal])\n            .nice(3)\n            .range([this.dims.height - this.margin.bottom, this.margin.top]);\n        // Updating margins\n        this.margin.left = this.getTextSize((0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.axisNumberFormat).format(this.formatStyle)(this._yAxis.domain()[1])) + this.yPadding + 3;\n        /****  Update xAxis ****/\n        const oldDomain = this._xAxis.domain();\n        this.initXAxis();\n        this._lineChartContainer\n            .transition('position')\n            .duration(400)\n            .ease(_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.p)\n            .attr('width', this.dims.width).attr('height', this.dims.height)\n            .attr('transform', `translate(${this.margin.left},0)`);\n        this.setYTicks();\n        this.defineLineAndScale();\n        //this.leftSetAxis();\n        this.addSymbols(true);\n        if (this._loading) {\n            (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._host).select('.tableButton').style('display', null);\n            this.addListenersToChart();\n            const height = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._titleDiv).style('height');\n            (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._titleDiv)\n                .style('height', this._prevHeight)\n                .transition('adjust')\n                .duration(400)\n                .style('height', height)\n                .on('end', () => (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._titleDiv).style('height', null));\n            (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._legendDiv).style('opacity', 0)\n                .transition()\n                .duration(400)\n                .ease(_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.p)\n                .style('opacity', 1);\n            this._lineChartContainer\n                .selectAll('.linePath').on('end', null);\n            // Setting starting state for symbols\n            this._lineChartContainer.selectAll('.symbolGroup')\n                .selectAll('.symbol')\n                .attr('opacity', 0)\n                .attr('transform', (d) => d ? `translate(${this._lineScale(d.x)},${this._yAxis(this._yAxis.domain()[0])})` : null);\n            this._lineChartContainer\n                .selectAll('.linePath')\n                .transition().duration(400).ease(quadInOut)\n                .attr(\"stroke-dashoffset\", function () {\n                return -this.getTotalLength();\n            })\n                .on('end', () => {\n                this._lineChartContainer\n                    .selectAll('.linePath')\n                    .data(this.reshapeData(this._chartData.data.series))\n                    .join('path')\n                    .attr('class', 'linePath')\n                    .attr('stroke', (d) => this.colorFunction(d))\n                    .attr(\"stroke-linecap\", \"round\")\n                    .attr('stroke-width', 4)\n                    .attr('fill', 'none')\n                    .attr('stroke-dasharray', this.dashFunction)\n                    .attr(\"stroke-dashoffset\", null)\n                    .attr('d', (d) => this._LineFunc(d.line.map((pair) => [pair[0], this._yAxis.domain()[0]])));\n                // Transitioning in lines\n                this._lineChartContainer\n                    .selectAll('.linePath').transition()\n                    .duration(400)\n                    .ease(_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.p)\n                    .attr('d', (d) => this._LineFunc(d.line));\n                // Transitioning in symbols\n                this._lineChartContainer.selectAll('.symbolGroup')\n                    .selectAll('.symbol')\n                    .transition().duration(400).ease(_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.p)\n                    .attr('transform', (d) => d ? `translate(${this._lineScale(d.x)},${this._yAxis(d.val)})` : null)\n                    .attr('opacity', 1);\n                this._loading = false;\n            });\n        }\n        else {\n            this._lineChartContainer\n                .selectAll('.linePath')\n                .data(this.reshapeData(this._chartData.data.series))\n                .join('path')\n                .transition()\n                .duration(400)\n                .ease(_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.p)\n                .attr('class', 'linePath')\n                .attr('stroke', (d) => this.colorFunction(d))\n                .attr(\"stroke-linecap\", \"round\")\n                .attr('stroke-width', (d) => d.length > 1 ? 4 : 6)\n                .attr('fill', 'none')\n                .attr('stroke-dasharray', (d, i) => d.length > 1 ? this.dashFunction(d, i) : null)\n                .attr('d', (d) => this._LineFunc(d.line));\n        }\n        // If we have the exact same domain, the tooltip may continue to be active\n        if (this._toggled && oldDomain === this._xAxis.domain()) {\n            const stringPoint = this._chartData.data.xValues[this._tooltipDataIndex].toString();\n            this._Circles\n                .selectAll('circle')\n                .data(this._chartData.data.series)\n                .join('circle')\n                .transition('New circles')\n                .duration(400)\n                .ease(_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.p)\n                .attr('stroke', 'white')\n                .attr('fill', (d) => this.colorFunction(d))\n                .attr('stroke-width', '1px')\n                .attr('r', 7);\n            this.positionCircles(stringPoint, 400);\n            const oldPos = this._TooltipLine.attr('y1');\n            this._TooltipLine\n                .transition()\n                .duration(400)\n                .ease(_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.p)\n                .attr('x1', this._xAxis(stringPoint) + this.margin.left)\n                .attr('x2', this._xAxis(stringPoint) + this.margin.left)\n                .attr('y1', this._yAxis(this._maxVal))\n                .attr('y2', this.dims.height - this.margin.bottom);\n            let tooltipBody = this._tooltip.select(\".tooltipBody\");\n            tooltipBody.select(this._tooltipHeading)\n                .style('margin', '0 0.75rem')\n                .html(() => {\n                if (this._chartData.data.xValueNames)\n                    return this._chartData.data.xValueNames[this._tooltipPoint - 1];\n                return this._tooltipPoint;\n            });\n            // Body\n            tooltipBody\n                .selectAll('div')\n                .data(this._chartData.data.series)\n                .join('div')\n                .style(\"display\", \"flex\")\n                .style(\"flex-direction\", \"row\")\n                .style(\"flex-wrap\", \"nowrap\")\n                .style(\"white-space\", \"nowrap\")\n                .style(\"justify-content\", \"space-between\")\n                .html((d) => {\n                return '<span>' + d.title + ':&nbsp</span><span class=\"tooltipVal\">' + d.yValues[this._tooltipDataIndex] + '</span>';\n            });\n            this.positionTooltipWithinBounds(this._xAxis(stringPoint) + this.margin.left, 400);\n            this._tooltip\n                .style('transform', () => {\n                // We reset the position of the tooltip, and adjust for the maximum value, -1px for it to align perfectly\n                return `translateY(${oldPos - this._tooltip.node().getBoundingClientRect().height - 9}px)`;\n            })\n                .transition()\n                .duration(400)\n                .ease(_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.p)\n                .style('transform', () => {\n                // We reset the position of the tooltip, and adjust for the maximum value, -1px for it to align perfectly\n                return `translateY(${this._yAxis(this._maxVal) - this._tooltip.node().getBoundingClientRect().height - 9}px)`;\n            });\n            this._svg.select('.tooltipPointer')\n                .transition()\n                .duration(400)\n                .ease(_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.p)\n                .attr(\"transform\", `translate(${this._xAxis(stringPoint) + this.margin.left},${this._yAxis(this._maxVal) - 7}) rotate(180) scale(1.5,1.0)`);\n        }\n        else {\n            this._Circles\n                .selectAll('circle')\n                .data(this._chartData.data.series)\n                .join('circle')\n                .attr('stroke', (d) => this.colorFunction(d))\n                .attr('fill', 'white')\n                .attr('stroke-width', '1px')\n                .attr('r', 7)\n                .attr('display', 'none');\n            this.closeTooltip();\n        }\n    }\n    componentWillLoad() {\n        this.afChartDataUpdate();\n    }\n    componentDidLoad() {\n        if (Object.keys(this._chartData).length === 0)\n            return this.initEmpty();\n        // clearing selection\n        this._selectedLines = [];\n        this.initSvg();\n        this.initLegend();\n        this.initLines();\n        document.fonts.onloadingdone = () => {\n            this.setTickSize();\n            this.resizeSvg();\n        };\n    }\n    componentWillUpdate() {\n        this._prevHeight = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._titleDiv).style('height');\n    }\n    componentDidUpdate() {\n        if (Object.keys(this._chartData).length === 0)\n            return this.loadingState();\n        // clearing selection\n        this._selectedLines = [];\n        this.updateSvg();\n        this.initLegend();\n        this.updateTableContent();\n    }\n    // Returns pixelwidth of text given the current fontSize (costly function using .each)\n    getTextSize(text) {\n        var textWidth = [];\n        let svg = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._chartDiv).append('svg');\n        svg\n            .selectAll('dummyText')\n            .data([text])\n            .join('text')\n            .attr('font-size', this.fontSize)\n            .text((d) => d)\n            .each((...[, i, nodelist]) => {\n            var thisWidth = nodelist[i].getComputedTextLength();\n            textWidth.push(thisWidth);\n            nodelist[i].remove();\n        });\n        svg.remove().exit();\n        return textWidth[0];\n    }\n    // Goes through all tick values and checks the biggest in size, this one will decide the default tick-size\n    setTickSize() {\n        if (this._chartData.data.xValueNames) {\n            for (const elem of this._chartData.data.xValueNames) {\n                const size = this.getTextSize(elem);\n                if (size > this._tickSize)\n                    this._tickSize = size;\n            }\n        }\n        else {\n            for (const elem of this._chartData.data.xValues) {\n                const size = this.getTextSize(elem.toString());\n                if (size > this._tickSize)\n                    this._tickSize = size;\n            }\n        }\n    }\n    // Left-orients Y-axis text\n    leftSetAxis(init = false) {\n        let shiftArray = [];\n        if (!init) {\n            this._yAxisHandle.selectAll(\"text\")\n                .transition('shuffle text')\n                .duration(400)\n                .attr(\"transform\", (...[, i, nodelist]) => {\n                const size = nodelist[i].getComputedTextLength();\n                shiftArray.push(size);\n                return `translate(${-1 * ((this.margin.left) - (size + this.yPadding))},0)`;\n            });\n            this._yAxisHandle.selectAll(\"line\")\n                .transition('shuffle line')\n                .duration(400)\n                .attr(\"x1\", (...[, i]) => {\n                return -1 * ((this.margin.left) - (shiftArray[i] + this.yPadding));\n            });\n        }\n        else {\n            this._yAxisHandle.selectAll(\"text\")\n                .attr(\"transform\", (...[, i, nodelist]) => {\n                const size = nodelist[i].getComputedTextLength();\n                shiftArray.push(size);\n                return `translate(${-1 * ((this.margin.left) - (size + this.yPadding))},0)`;\n            });\n            this._yAxisHandle.selectAll(\"line\")\n                .attr(\"x1\", (...[, i]) => {\n                return -1 * ((this.margin.left) - (shiftArray[i] + this.yPadding));\n            });\n        }\n    }\n    // Updating data if content changes\n    updateTableContent() {\n        if (this._tableDiv.style['display'] === '' || this._tableDiv.style['display'] === 'none')\n            return;\n        this.setTableContent();\n        this.animateTableDimensions();\n    }\n    // Setting table content from this._chartData\n    setTableContent() {\n        this._tableDiv.innerHTML = `<digi-table af-size=\"small\" af-variation=\"primary\"> <table><caption>${this._chartData.title}</caption><thead><tr>${this.headings()}</tr></thead><tbody>${this.tableBody()}</tbody></table></digi-table>`;\n    }\n    setTableDimensions() {\n        const table = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._tableDiv);\n        table\n            // The last value is for compensating the padding set on the table element, changing padding in css, will need change in these two lines\n            .style('height', (this._maxHeight - (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._titleDiv).node().getBoundingClientRect().height - (parseFloat(getComputedStyle(document.documentElement).fontSize) * 0.65)) + 'px');\n        table.style('width', (this.dims.width - parseFloat(getComputedStyle(document.documentElement).fontSize) * 0.65) + 'px');\n    }\n    animateTableDimensions() {\n        const height = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._titleDiv).style('height');\n        (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._titleDiv)\n            .style('height', this._prevHeight)\n            .transition('adjust')\n            .duration(400)\n            .style('height', height)\n            .on('end', () => (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._titleDiv).style('height', null));\n        const table = (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.s)(this._tableDiv);\n        table\n            .transition('adjustHeight')\n            .duration(400)\n            // The last value is for compensating the padding set on the table element, changing padding in css, will need change in these two lines\n            .style('height', (this._maxHeight - (parseFloat(height) + (parseFloat(getComputedStyle(document.documentElement).fontSize) * 1.25)) - (parseFloat(getComputedStyle(document.documentElement).fontSize) * 0.65)) + 'px');\n        table.style('width', (this.dims.width - parseFloat(getComputedStyle(document.documentElement).fontSize) * 0.65) + 'px');\n    }\n    // Extracting all headings from data and returning a string with <th>-elements with headings\n    headings() {\n        let headingsString = `<th scope=\"col\">${this._chartData.x}</th>`;\n        this._coreSeries.forEach((elem) => {\n            headingsString = headingsString.concat(`<th scope=\"col\">${elem.title}</th>`);\n        });\n        return headingsString;\n    }\n    // Building the table body \n    tableBody() {\n        let body = '';\n        const loopable = this._chartData.data.xValueNames ? this._chartData.data.xValueNames : this._chartData.data.xValues;\n        loopable.forEach((elem, index) => {\n            let cells = '';\n            this._coreSeries.forEach((serie) => {\n                cells = cells.concat(`<td>${serie.yValues[index] != null ? (0,_linear_ef018ffb_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.axisNumberFormat).format(this.formatStyle)(serie.yValues[index]) : '-'}</td>`);\n            });\n            body = body.concat(`<tr><th scope='row'>${elem}${cells}</th></tr>`);\n        });\n        return body;\n    }\n    render() {\n        let heading = '';\n        if (!this._chartData.subTitle)\n            heading = `<${this.afHeadingLevel}>${this._chartData.title}</${this.afHeadingLevel}>`;\n        else\n            heading = `<${this.afHeadingLevel}>${this._chartData.title}</${this.afHeadingLevel}><p>${this._chartData.subTitle}</p>`;\n        return ((0,_index_de760108_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"host\", { key: 'e203ccb4cd2ed24d5347179d4d4049c152f2a571', ref: (el) => (this._host = el) }, (0,_index_de760108_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { key: 'bc838750c2c40748dbafe42cccbf2d5f26739615', class: \"topWrapper\", ref: (el) => (this._titleDiv = el) }, (0,_index_de760108_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"digi-typography\", { key: '745bacead1338696dcb658daf3acdec73d931d91', class: \"chartTitle\", innerHTML: heading }), (0,_index_de760108_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"digi-button\", { key: '36c3a370406377e66416992455800dab721195c8', class: \"buttonWrapper tableButton\", \"af-size\": \"medium\", \"af-variation\": \"function\", \"af-full-width\": \"false\", onAfOnClick: this.activateTable, afAriaLabel: `Visa tabell ${this._chartData.title ? this._chartData.title.toLowerCase() : ''}` }, (0,_index_de760108_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"digi-icon-table\", { key: '215f84868e1964fa2b1693d11f6ec554b6798c67', slot: \"icon\" }), \"Visa tabell\"), (0,_index_de760108_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"digi-button\", { key: 'bb009c925a0e3956cb9042dffb52b6910ee50dd5', style: { 'display': 'none' }, class: \"buttonWrapper chartButton\", \"af-size\": \"medium\", \"af-variation\": \"function\", \"af-full-width\": \"false\", onAfOnClick: this.reInitChart, afAriaLabel: `Visa diagram ${this._chartData.title ? this._chartData.title.toLowerCase() : ''}` }, (0,_index_de760108_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"digi-icon-chart\", { key: '77a0e4660f68bdd25cee8de59941460903886e2a', slot: \"icon\" }), \"Visa diagram\"), (0,_index_de760108_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { key: 'b001a98759237f85921551a43f80332cb12869be', class: \"scChartStatus\", role: \"status\", ref: (el) => (this._status = el) })), (0,_index_de760108_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { key: 'b24edbf93130b4e6b23b3331259f5a7db75ccc39', class: \"chartTooltip\", id: this.afId }, (0,_index_de760108_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { key: '4094c14291335f1e85f78376b71f13b2ad3dfeb6', class: \"tooltipBody\" }), (0,_index_de760108_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"digi-icon-x\", { key: '185d0563d0939d1985324df7663731a4da932269', class: \"close\" }), \" \"), (0,_index_de760108_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { key: '993fc3bec56f7a7aa50a8f9f6ff5657f710f4c80', class: \"chart\", ref: (el) => (this._chartDiv = el) }), (0,_index_de760108_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { key: 'f61d8cd1065d50c2a99ac6cf9598d3c4935c1dbc', class: \"legend\", ref: (el) => (this._legendDiv = el) }), (0,_index_de760108_js__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { key: 'fb3c27c749b692b8d44ed4ca6134927f3c982d24', class: \"table\", ref: (el) => (this._tableDiv = el) }, \" \")));\n    }\n    get element() { return (0,_index_de760108_js__WEBPACK_IMPORTED_MODULE_0__.g)(this); }\n    static get watchers() { return {\n        \"afChartData\": [\"afChartDataUpdate\"]\n    }; }\n};\nChartLine.style = DigiChartLineStyle0;\n\n\n\n\n//# sourceURL=webpack://yaml-generator/./node_modules/@digi/arbetsformedlingen/dist/esm/digi-chart-line.entry.js?");

/***/ })

}]);